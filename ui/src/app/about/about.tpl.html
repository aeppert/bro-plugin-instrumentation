<div class="row">
    <h4>Overview</h4>
    <p>This page is a client-side HTML / JS application designed to offer a basic user interface for browsing the results of a single execution of Bro.  Results are split into three parts, corresponding 
    to the three different types of profiling output generated by the plugin.</p>
    <h5>Runtime</h5>
    <p>The first type of output is 'runtime' output, or statistics gathered every X seconds.  This type of output is designed to offer insight into how bro is performing overall (e.g. tracking memory 
    allocation, disk writes, etc).  Currently, the following metrics are reported:</p>
    <ul>
        <li>Cycles - The total number of CPU cycles spent processing packets in bro.</li>
        <li>Packets - The total number of packets bro has seen thus far.</li>
        <li>Bytes (Written|Read) - The total number of bytes bro has written to / read from disk.  Caveat: this relies on hooks that intercept calls to 'read' and 'write' ... as such, data written or read that didn't use these calls won't be reflected in these numbers.</li>
        <li>malloc count / malloc size / free count - The number of times bro has called 'malloc' and 'free'.  This is a metric to report on the total number of allocations bro has made thus far.  malloc size records how much <strong>total</strong> memory bro has requested: it does <strong>not</strong> reflect the amount of memory in use by the process.<li>
        <li>cycles / packet - On average, the number of cycles spent processing each individual packet (calculated since the last time statistics were gathered)</li>
        <li>packets / second - On average, the number of packets observed each second (calculated since the last time statistics were gathered)</li>
        <li>load - An estimate of how close the system is to capacity, reflected as a number between 0 and (approximately) 1.  This is a <strong>very</strong> rough guess.  It is calculated by first dividing 
        the average number of cycles taken to process each packet by the number of cycles the CPU has available to it each second: this estimates an upper bound on the number of packets bro can 
        process in a second, which we'll call 'capacity'.  If we divide the number of packets we observed during the last time period by the 'capacity' number we computed above, it produces a 
        number between 0 and 1.  This offers a <strong>very rough</strong> estimate of bro's load during the past X seconds or Y packets (depending on how the profiler is configured).  For example, a value 
        of 0.6 here would indicate that Bro was processing 60% of what we calculated its theoretical maximum (its capacity) to be.  This number is by no means perfect, and is here more as food for thought
        than anything else ...</li>
    </ul>
    <p>
    The X axis represents the time (in seconds) since bro received its first packet.
    </p>
    <p>
    It's possible to interact with the graph: clicking on the names of different fields will toggle whether or not they are displayed on the graph, and moving the cursor over a point on the graph will
    display a table showing the exact values for that data point.
    <p>
    Additionally, an option is offered to normalize the data (by clicking the blue button above the graph).  This transforms the data such that <strong>all</strong> values fit between '0' and '1'.  This
    allows all the different metrics to share a common scale, and offers a way to search for patterns in the recorded data (e.g. "my memory allocation is increasing with the number of packets squared ...
    my server will probably catch fire soon").
    </p>
    <h5>Function Profile</h5>
    <p>
    This section offers a list of how many times each individual bro function was called, how much CPU time was spent in the function, and how many times the function allocated memory while it was running.
    CPU numbers are aggregate: these values record the total time spent in this function <strong>or</strong> any of the functions it calls in turn.  In practice, this means that it's quite likely that the
    total CPU seconds recorded across all bro script functions can add up to a number that is higher than the total number of CPU seconds bro actually spent running the program.
    </p>
    <p>
    Results may be sorted in three ways:
    </p>
        <ul>
            <li>cycles</li> - sort by the total number of cycles consumed by the function (CPU seconds)
            <li>malloc</li> - sort by the total number of allocations made by the function
            <li>count</li> - sort by the total number of times the function was called
        </ul>
    <h5>Call Graph</h5>
    <p>
    The call graph is an overview of which functions called which other functions while bro was executing.  This is usually an <strong>incredibly</strong> large picture for nontrivial applications, since
    bro normally calls a large number of functions (e.g. to initialize logging streams and the like).
    </p>
    <h4>Using this UI</h4>
    <p>
    The easiest way to get going with this UI at the moment is as follows:
    </p>
    <ul>
        <li>Clone the https://github.com/cubic1271/bro-plugin-instrumentation repository</li>
        <li>Execute bro with instrumentation enabled (e.g. with the provided instrument.bro script in the root of the repository)</li>
        <li>Copy the resulting bro-profile-collection file into the 'ui/bin' directory as 'collection.json'</li>
        <li>Copy the resulting bro-profile-function file into the 'ui/bin' directory as 'profile.json'</li>
        <li>Execute 'unflatten' and 'dot' as described in the bro-plugin-instrumentation README.md, and copy the resulting callgraph image to the 'bin' directory as 'callgraph.png'</li>
        <li>Change directory to 'ui/bin' and execute 'python -m SimpleHTTPServer'</li>
        <li>Open http://localhost:8000 in a browser of choice</li>
    </ul>
    <h4>Notess</h4>
    <p>Skeleton generated by <a href='https://github.com/ngbp/ngbp'>ngBoilerplate</a></p>
</div>

